import * as util from 'util'
import { BlenderCollection, Indexable } from '../../collection'
import { BlenderInterop } from '../../../worker/interop'
import { PythonInterop } from '../../../python/interop'
import { ColorRamp } from './ColorRamp'
import { EffectorWeights } from './EffectorWeights'
import { FluidDomainVertexVelocity } from './FluidDomainVertexVelocity'
import { PointCache } from './PointCache'
import { Collection } from './Collection'
import { BlenderObject } from './BlenderObject'

/**
 * FluidDomainSettings
 * 
 * https://docs.blender.org/api/current/bpy.types.FluidDomainSettings.html
 */
export class FluidDomainSettings {

    constructor(public interop: BlenderInterop, public accessor: string) { }

    /**
     * Cell Size
     * @desc float array of 3 items in [-inf, inf], default (0.0, 0.0, 0.0), (readonly)
     */
    public get cell_size(): [number, number, number] {
        return PythonInterop.getArray(this.interop, `${this.accessor}.cell_size`, 'number', 3)
    }

    /**
     * Smoke color grid
     * @desc float array of 32 items in [-inf, inf], default (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0), (readonly)
     */
    public get color_grid(): [number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number] {
        return PythonInterop.getArray(this.interop, `${this.accessor}.color_grid`, 'number', 32)
    }

    /**
     * 
     * @desc ColorRamp, (readonly)
     */
    public get color_ramp(): ColorRamp {
        return PythonInterop.getClass(this.interop, `${this.accessor}.color_ramp`, ColorRamp)
    }

    /**
     * Smoke density grid
     * @desc float array of 32 items in [-inf, inf], default (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0), (readonly)
     */
    public get density_grid(): [number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number] {
        return PythonInterop.getArray(this.interop, `${this.accessor}.density_grid`, 'number', 32)
    }

    /**
     * Smoke Grid Resolution
     * @desc int array of 3 items in [-inf, inf], default (0, 0, 0), (readonly)
     */
    public get domain_resolution(): [number, number, number] {
        return PythonInterop.getArray(this.interop, `${this.accessor}.domain_resolution`, 'number', 3)
    }

    /**
     * 
     * @desc EffectorWeights, (readonly)
     */
    public get effector_weights(): EffectorWeights {
        return PythonInterop.getClass(this.interop, `${this.accessor}.effector_weights`, EffectorWeights)
    }

    /**
     * Smoke flame grid
     * @desc float array of 32 items in [-inf, inf], default (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0), (readonly)
     */
    public get flame_grid(): [number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number] {
        return PythonInterop.getArray(this.interop, `${this.accessor}.flame_grid`, 'number', 32)
    }

    /**
     * Smoke heat grid
     * @desc float array of 32 items in [-inf, inf], default (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0), (readonly)
     */
    public get heat_grid(): [number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number] {
        return PythonInterop.getArray(this.interop, `${this.accessor}.heat_grid`, 'number', 32)
    }

    /**
     * Vertices of the fluid mesh generated by simulation
     * @desc bpy_prop_collection of FluidDomainVertexVelocity, (readonly)
     */
    public get mesh_vertices(): BlenderCollection<FluidDomainVertexVelocity> & Indexable<FluidDomainVertexVelocity> {
        return BlenderCollection.createGeneric(this.interop, `${this.accessor}.mesh_vertices`, FluidDomainVertexVelocity)
    }

    /**
     * 
     * @desc PointCache, (readonly, never None)
     */
    public get point_cache(): PointCache {
        return PythonInterop.getClass(this.interop, `${this.accessor}.point_cache`, PointCache)
    }

    /**
     * Start point
     * @desc float array of 3 items in [-inf, inf], default (0.0, 0.0, 0.0), (readonly)
     */
    public get start_point(): [number, number, number] {
        return PythonInterop.getArray(this.interop, `${this.accessor}.start_point`, 'number', 3)
    }

    /**
     * Smoke temperature grid, range 0..1 represents 0..1000K
     * @desc float array of 32 items in [-inf, inf], default (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0), (readonly)
     */
    public get temperature_grid(): [number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number] {
        return PythonInterop.getArray(this.interop, `${this.accessor}.temperature_grid`, 'number', 32)
    }

    /**
     * Smoke velocity grid
     * @desc float array of 32 items in [-inf, inf], default (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0), (readonly)
     */
    public get velocity_grid(): [number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number] {
        return PythonInterop.getArray(this.interop, `${this.accessor}.velocity_grid`, 'number', 32)
    }

    /**
     * Margin added around fluid to minimize boundary interference
     * @desc int in [2, 24], default 0
     */
    public get adapt_margin(): number {
        return PythonInterop.getInteger(this.interop, `${this.accessor}.adapt_margin`)
    }

    /**
     * Maximum amount of fluid cell can contain before it is considered empty
     * @desc float in [0, 1], default 0.0
     */
    public get adapt_threshold(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.adapt_threshold`)
    }

    /**
     * Maximum number of additional cells
     * @desc int in [0, 512], default 0
     */
    public get additional_res(): number {
        return PythonInterop.getInteger(this.interop, `${this.accessor}.additional_res`)
    }

    /**
     * Buoyant force based on smoke density (higher value results in faster rising smoke)
     * @desc float in [-5, 5], default 0.0
     */
    public get alpha(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.alpha`)
    }

    /**
     * 
     * @desc enum in ['FULL', 'SINGLE'], default 'FULL'
     */
    public get axis_slice_method(): 'FULL' | 'SINGLE' {
        return PythonInterop.getEnum(this.interop, `${this.accessor}.axis_slice_method`)
    }

    /**
     * Buoyant force based on smoke heat (higher value results in faster rising smoke)
     * @desc float in [-5, 5], default 0.0
     */
    public get beta(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.beta`)
    }

    /**
     * Speed of the burning reaction (higher value results in smaller flames)
     * @desc float in [0.01, 4], default 0.0
     */
    public get burning_rate(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.burning_rate`)
    }

    /**
     * Select the file format to be used for caching volumetric data
     * @desc enum in ['NONE'], default 'NONE'
     */
    public get cache_data_format(): 'NONE' {
        return PythonInterop.getEnum(this.interop, `${this.accessor}.cache_data_format`)
    }

    /**
     * Directory that contains fluid cache files
     * @desc string, default '', (never None)
     */
    public get cache_directory(): string {
        return PythonInterop.getString(this.interop, `${this.accessor}.cache_directory`)
    }

    /**
     * Frame on which the simulation stops
     * @desc int in [1, 1048574], default 0
     */
    public get cache_frame_end(): number {
        return PythonInterop.getInteger(this.interop, `${this.accessor}.cache_frame_end`)
    }

    /**
     * 
     * @desc int in [-inf, inf], default 0
     */
    public get cache_frame_pause_data(): number {
        return PythonInterop.getInteger(this.interop, `${this.accessor}.cache_frame_pause_data`)
    }

    /**
     * 
     * @desc int in [-inf, inf], default 0
     */
    public get cache_frame_pause_guide(): number {
        return PythonInterop.getInteger(this.interop, `${this.accessor}.cache_frame_pause_guide`)
    }

    /**
     * 
     * @desc int in [-inf, inf], default 0
     */
    public get cache_frame_pause_mesh(): number {
        return PythonInterop.getInteger(this.interop, `${this.accessor}.cache_frame_pause_mesh`)
    }

    /**
     * 
     * @desc int in [-inf, inf], default 0
     */
    public get cache_frame_pause_noise(): number {
        return PythonInterop.getInteger(this.interop, `${this.accessor}.cache_frame_pause_noise`)
    }

    /**
     * 
     * @desc int in [-inf, inf], default 0
     */
    public get cache_frame_pause_particles(): number {
        return PythonInterop.getInteger(this.interop, `${this.accessor}.cache_frame_pause_particles`)
    }

    /**
     * Frame on which the simulation starts
     * @desc int in [-1048574, 1048574], default 0
     */
    public get cache_frame_start(): number {
        return PythonInterop.getInteger(this.interop, `${this.accessor}.cache_frame_start`)
    }

    /**
     * Select the file format to be used for caching surface data
     * @desc enum in ['NONE'], default 'NONE'
     */
    public get cache_mesh_format(): 'NONE' {
        return PythonInterop.getEnum(this.interop, `${this.accessor}.cache_mesh_format`)
    }

    /**
     * Select the file format to be used for caching noise data
     * @desc enum in ['NONE'], default 'NONE'
     */
    public get cache_noise_format(): 'NONE' {
        return PythonInterop.getEnum(this.interop, `${this.accessor}.cache_noise_format`)
    }

    /**
     * Select the file format to be used for caching particle data
     * @desc enum in ['NONE'], default 'NONE'
     */
    public get cache_particle_format(): 'NONE' {
        return PythonInterop.getEnum(this.interop, `${this.accessor}.cache_particle_format`)
    }

    /**
     * Change the cache type of the simulation
     * @desc enum in ['REPLAY', 'MODULAR', 'FINAL'], default 'REPLAY'
     */
    public get cache_type(): 'REPLAY' | 'MODULAR' | 'FINAL' {
        return PythonInterop.getEnum(this.interop, `${this.accessor}.cache_type`)
    }

    /**
     * Maximal velocity per cell (higher value results in greater timesteps)
     * @desc float in [0, 10], default 0.0
     */
    public get cfl_condition(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.cfl_condition`)
    }

    /**
     * Value under which voxels are considered empty space to optimize caching and rendering
     * @desc float in [0, 1], default 0.0
     */
    public get clipping(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.clipping`)
    }

    /**
     * Simulation field to color map
     * @desc enum in ['COLOR_R', 'COLOR_G', 'COLOR_B', 'DENSITY', 'FLAME', 'FUEL', 'HEAT', 'VELOCITY_X', 'VELOCITY_Y', 'VELOCITY_Z'], default 'DENSITY'
     */
    public get coba_field(): 'COLOR_R' | 'COLOR_G' | 'COLOR_B' | 'DENSITY' | 'FLAME' | 'FUEL' | 'HEAT' | 'VELOCITY_X' | 'VELOCITY_Y' | 'VELOCITY_Z' {
        return PythonInterop.getEnum(this.interop, `${this.accessor}.coba_field`)
    }

    /**
     * Bit depth for writing all scalar (including vector) lower values reduce file size
     * @desc enum in ['16', '32'], default '32'
     */
    public get data_depth(): '16' | '32' {
        return PythonInterop.getEnum(this.interop, `${this.accessor}.data_depth`)
    }

    /**
     * Interpolation method to use for smoke/fire volumes in solid mode
     * @desc enum in ['LINEAR', 'CUBIC'], default 'LINEAR'
     */
    public get display_interpolation(): 'LINEAR' | 'CUBIC' {
        return PythonInterop.getEnum(this.interop, `${this.accessor}.display_interpolation`)
    }

    /**
     * Thickness of smoke drawing in the viewport
     * @desc float in [0.001, 1000], default 0.0
     */
    public get display_thickness(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.display_thickness`)
    }

    /**
     * Determine how quickly the smoke dissolves (higher value makes smoke disappear faster)
     * @desc int in [1, 10000], default 0
     */
    public get dissolve_speed(): number {
        return PythonInterop.getInteger(this.interop, `${this.accessor}.dissolve_speed`)
    }

    /**
     * Domain size in meters (longest domain side)
     * @desc float in [0.001, 10000], default 0.0
     */
    public get domain_size(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.domain_size`)
    }

    /**
     * Change domain type of the simulation
     * @desc enum in ['GAS', 'LIQUID'], default 'GAS'
     */
    public get domain_type(): 'GAS' | 'LIQUID' {
        return PythonInterop.getEnum(this.interop, `${this.accessor}.domain_type`)
    }

    /**
     * Limit effectors to this collection
     * @desc Collection
     */
    public get effector_group(): Collection {
        return PythonInterop.getClass(this.interop, `${this.accessor}.effector_group`, Collection)
    }

    /**
     * Generate and export Fluidflow script from current domain settings during bake. This is only needed if you plan to analyse the cache (e.g. view grids, velocity vectors, particles) in Fluidflow directly (outside of Blender) after baking the simulation
     * @desc boolean, default False
     */
    public get export_manta_script(): boolean {
        return PythonInterop.getBoolean(this.interop, `${this.accessor}.export_manta_script`)
    }

    /**
     * Minimum temperature of the flames (higher value results in faster rising flames)
     * @desc float in [0.5, 5], default 0.0
     */
    public get flame_ignition(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.flame_ignition`)
    }

    /**
     * Maximum temperature of the flames (higher value results in faster rising flames)
     * @desc float in [1, 10], default 0.0
     */
    public get flame_max_temp(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.flame_max_temp`)
    }

    /**
     * Amount of smoke created by burning fuel
     * @desc float in [0, 8], default 0.0
     */
    public get flame_smoke(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.flame_smoke`)
    }

    /**
     * Color of smoke emitted from burning fuel
     * @desc float array of 3 items in [0, inf], default (0.0, 0.0, 0.0)
     */
    public get flame_smoke_color(): [number, number, number] {
        return PythonInterop.getArray(this.interop, `${this.accessor}.flame_smoke_color`, 'number', 3)
    }

    /**
     * Additional vorticity for the flames
     * @desc float in [0, 2], default 0.0
     */
    public get flame_vorticity(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.flame_vorticity`)
    }

    /**
     * PIC/FLIP Ratio. A value of 1.0 will result in a completely FLIP based simulation. Use a lower value for simulations which should produce smaller splashes
     * @desc float in [0, 1], default 0.0
     */
    public get flip_ratio(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.flip_ratio`)
    }

    /**
     * Limit fluid objects to this collection
     * @desc Collection
     */
    public get fluid_group(): Collection {
        return PythonInterop.getClass(this.interop, `${this.accessor}.fluid_group`, Collection)
    }

    /**
     * Limit forces to this collection
     * @desc Collection
     */
    public get force_collection(): Collection {
        return PythonInterop.getClass(this.interop, `${this.accessor}.force_collection`, Collection)
    }

    /**
     * Determines how much fluid is allowed in an obstacle cell (higher values will tag a boundary cell as an obstacle easier and reduce the boundary smoothening effect)
     * @desc float in [0.001, 1], default 0.0
     */
    public get fractions_threshold(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.fractions_threshold`)
    }

    /**
     * Gravity in X, Y and Z direction
     * @desc float array of 3 items in [-1000.1, 1000.1], default (0.0, 0.0, 0.0)
     */
    public get gravity(): [number, number, number] {
        return PythonInterop.getArray(this.interop, `${this.accessor}.gravity`, 'number', 3)
    }

    /**
     * Guiding weight (higher value results in greater lag)
     * @desc float in [1, 100], default 0.0
     */
    public get guide_alpha(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.guide_alpha`)
    }

    /**
     * Guiding size (higher value results in larger vortices)
     * @desc int in [1, 50], default 0
     */
    public get guide_beta(): number {
        return PythonInterop.getInteger(this.interop, `${this.accessor}.guide_beta`)
    }

    /**
     * Use velocities from this object for the guiding effect (object needs to have fluid modifier and be of type domain))
     * @desc Object
     */
    public get guide_parent(): BlenderObject {
        return PythonInterop.getClass(this.interop, `${this.accessor}.guide_parent`, BlenderObject)
    }

    /**
     * Choose where to get guiding velocities from
     * @desc enum in ['DOMAIN', 'EFFECTOR'], default 'DOMAIN'
     */
    public get guide_source(): 'DOMAIN' | 'EFFECTOR' {
        return PythonInterop.getEnum(this.interop, `${this.accessor}.guide_source`)
    }

    /**
     * Guiding velocity factor (higher value results in greater guiding velocities)
     * @desc float in [0, 100], default 0.0
     */
    public get guide_vel_factor(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.guide_vel_factor`)
    }

    /**
     * 
     * @desc boolean, default False
     */
    public get has_cache_baked_any(): boolean {
        return PythonInterop.getBoolean(this.interop, `${this.accessor}.has_cache_baked_any`)
    }

    /**
     * 
     * @desc boolean, default False
     */
    public get has_cache_baked_data(): boolean {
        return PythonInterop.getBoolean(this.interop, `${this.accessor}.has_cache_baked_data`)
    }

    /**
     * 
     * @desc boolean, default False
     */
    public get has_cache_baked_guide(): boolean {
        return PythonInterop.getBoolean(this.interop, `${this.accessor}.has_cache_baked_guide`)
    }

    /**
     * 
     * @desc boolean, default False
     */
    public get has_cache_baked_mesh(): boolean {
        return PythonInterop.getBoolean(this.interop, `${this.accessor}.has_cache_baked_mesh`)
    }

    /**
     * 
     * @desc boolean, default False
     */
    public get has_cache_baked_noise(): boolean {
        return PythonInterop.getBoolean(this.interop, `${this.accessor}.has_cache_baked_noise`)
    }

    /**
     * 
     * @desc boolean, default False
     */
    public get has_cache_baked_particles(): boolean {
        return PythonInterop.getBoolean(this.interop, `${this.accessor}.has_cache_baked_particles`)
    }

    /**
     * Method for sampling the high resolution flow
     * @desc enum in ['FULLSAMPLE', 'LINEAR', 'NEAREST'], default 'NEAREST'
     */
    public get highres_sampling(): 'FULLSAMPLE' | 'LINEAR' | 'NEAREST' {
        return PythonInterop.getEnum(this.interop, `${this.accessor}.highres_sampling`)
    }

    /**
     * 
     * @desc boolean, default False
     */
    public get is_cache_baking_any(): boolean {
        return PythonInterop.getBoolean(this.interop, `${this.accessor}.is_cache_baking_any`)
    }

    /**
     * 
     * @desc boolean, default False
     */
    public get is_cache_baking_data(): boolean {
        return PythonInterop.getBoolean(this.interop, `${this.accessor}.is_cache_baking_data`)
    }

    /**
     * 
     * @desc boolean, default False
     */
    public get is_cache_baking_guide(): boolean {
        return PythonInterop.getBoolean(this.interop, `${this.accessor}.is_cache_baking_guide`)
    }

    /**
     * 
     * @desc boolean, default False
     */
    public get is_cache_baking_mesh(): boolean {
        return PythonInterop.getBoolean(this.interop, `${this.accessor}.is_cache_baking_mesh`)
    }

    /**
     * 
     * @desc boolean, default False
     */
    public get is_cache_baking_noise(): boolean {
        return PythonInterop.getBoolean(this.interop, `${this.accessor}.is_cache_baking_noise`)
    }

    /**
     * 
     * @desc boolean, default False
     */
    public get is_cache_baking_particles(): boolean {
        return PythonInterop.getBoolean(this.interop, `${this.accessor}.is_cache_baking_particles`)
    }

    /**
     * Lower mesh concavity bound (high values tend to smoothen and fill out concave regions)
     * @desc float in [0, 10], default 0.0
     */
    public get mesh_concave_lower(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.mesh_concave_lower`)
    }

    /**
     * Upper mesh concavity bound (high values tend to smoothen and fill out concave regions)
     * @desc float in [0, 10], default 0.0
     */
    public get mesh_concave_upper(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.mesh_concave_upper`)
    }

    /**
     * Which particle levelset generator to use
     * @desc enum in ['IMPROVED', 'UNION'], default 'IMPROVED'
     */
    public get mesh_generator(): 'IMPROVED' | 'UNION' {
        return PythonInterop.getEnum(this.interop, `${this.accessor}.mesh_generator`)
    }

    /**
     * Particle radius factor (higher value results in larger (meshed) particles). Needs to be adjusted after changing the mesh scale
     * @desc float in [0, 10], default 0.0
     */
    public get mesh_particle_radius(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.mesh_particle_radius`)
    }

    /**
     * The mesh simulation is scaled up by this factor (compared to the base resolution of the domain). For best meshing, it is recommended to adjust the mesh particle radius alongside this value
     * @desc int in [1, 100], default 0
     */
    public get mesh_scale(): number {
        return PythonInterop.getInteger(this.interop, `${this.accessor}.mesh_scale`)
    }

    /**
     * Negative mesh smoothening
     * @desc int in [0, 100], default 0
     */
    public get mesh_smoothen_neg(): number {
        return PythonInterop.getInteger(this.interop, `${this.accessor}.mesh_smoothen_neg`)
    }

    /**
     * Positive mesh smoothening
     * @desc int in [0, 100], default 0
     */
    public get mesh_smoothen_pos(): number {
        return PythonInterop.getInteger(this.interop, `${this.accessor}.mesh_smoothen_pos`)
    }

    /**
     * Scale of noise (higher value results in larger vortices)
     * @desc float in [0.0001, 10], default 0.0
     */
    public get noise_pos_scale(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.noise_pos_scale`)
    }

    /**
     * The noise simulation is scaled up by this factor (compared to the base resolution of the domain)
     * @desc int in [1, 100], default 0
     */
    public get noise_scale(): number {
        return PythonInterop.getInteger(this.interop, `${this.accessor}.noise_scale`)
    }

    /**
     * Strength of noise
     * @desc float in [0, 10], default 0.0
     */
    public get noise_strength(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.noise_strength`)
    }

    /**
     * Animation time of noise
     * @desc float in [0.0001, 10], default 0.0
     */
    public get noise_time_anim(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.noise_time_anim`)
    }

    /**
     * Noise method which is used during the high-res simulation
     * @desc enum in ['NOISEWAVE'], default 'NOISEWAVE'
     */
    public get noise_type(): 'NOISEWAVE' {
        return PythonInterop.getEnum(this.interop, `${this.accessor}.noise_type`)
    }

    /**
     * Compression method to be used
     * @desc enum in ['ZIP', 'BLOSC', 'NONE'], default 'BLOSC'
     */
    public get openvdb_cache_compress_type(): 'ZIP' | 'BLOSC' | 'NONE' {
        return PythonInterop.getEnum(this.interop, `${this.accessor}.openvdb_cache_compress_type`)
    }

    /**
     * Particle (narrow) band width (higher value results in thicker band and more particles)
     * @desc float in [0, 1000], default 0.0
     */
    public get particle_band_width(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.particle_band_width`)
    }

    /**
     * Maximum number of particles per cell (ensures that each cell has at most this amount of particles)
     * @desc int in [0, 1000], default 0
     */
    public get particle_max(): number {
        return PythonInterop.getInteger(this.interop, `${this.accessor}.particle_max`)
    }

    /**
     * Minimum number of particles per cell (ensures that each cell has at least this amount of particles)
     * @desc int in [0, 1000], default 0
     */
    public get particle_min(): number {
        return PythonInterop.getInteger(this.interop, `${this.accessor}.particle_min`)
    }

    /**
     * Particle number factor (higher value results in more particles)
     * @desc int in [1, 5], default 0
     */
    public get particle_number(): number {
        return PythonInterop.getInteger(this.interop, `${this.accessor}.particle_number`)
    }

    /**
     * Particle radius factor. Increase this value if the simulation appears to leak volume, decrease it if the simulation seems to gain volume
     * @desc float in [0, 10], default 0.0
     */
    public get particle_radius(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.particle_radius`)
    }

    /**
     * Randomness factor for particle sampling
     * @desc float in [0, 10], default 0.0
     */
    public get particle_randomness(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.particle_randomness`)
    }

    /**
     * The particle simulation is scaled up by this factor (compared to the base resolution of the domain)
     * @desc int in [1, 100], default 0
     */
    public get particle_scale(): number {
        return PythonInterop.getInteger(this.interop, `${this.accessor}.particle_scale`)
    }

    /**
     * Compression method to be used
     * @desc enum in ['CACHELIGHT', 'CACHEHEAVY'], default 'CACHELIGHT'
     */
    public get point_cache_compress_type(): 'CACHELIGHT' | 'CACHEHEAVY' {
        return PythonInterop.getEnum(this.interop, `${this.accessor}.point_cache_compress_type`)
    }

    /**
     * Resolution used for the fluid domain. Value corresponds to the longest domain side (resolution for other domain sides is calculated automatically)
     * @desc int in [6, 10000], default 0
     */
    public get resolution_max(): number {
        return PythonInterop.getInteger(this.interop, `${this.accessor}.resolution_max`)
    }

    /**
     * Toggle visualization of the velocity field as needles
     * @desc boolean, default False
     */
    public get show_velocity(): boolean {
        return PythonInterop.getBoolean(this.interop, `${this.accessor}.show_velocity`)
    }

    /**
     * Change the underlying simulation method
     * @desc enum in ['FLIP'], default 'FLIP'
     */
    public get simulation_method(): 'FLIP' {
        return PythonInterop.getEnum(this.interop, `${this.accessor}.simulation_method`)
    }

    /**
     * 
     * @desc enum in ['AUTO', 'X', 'Y', 'Z'], default 'AUTO'
     */
    public get slice_axis(): 'AUTO' | 'X' | 'Y' | 'Z' {
        return PythonInterop.getEnum(this.interop, `${this.accessor}.slice_axis`)
    }

    /**
     * Position of the slice
     * @desc float in [0, 1], default 0.0
     */
    public get slice_depth(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.slice_depth`)
    }

    /**
     * How to slice the volume for viewport rendering
     * @desc enum in ['VIEW_ALIGNED', 'AXIS_ALIGNED'], default 'VIEW_ALIGNED'
     */
    public get slice_method(): 'VIEW_ALIGNED' | 'AXIS_ALIGNED' {
        return PythonInterop.getEnum(this.interop, `${this.accessor}.slice_method`)
    }

    /**
     * How many slices per voxel should be generated
     * @desc float in [0, 100], default 0.0
     */
    public get slice_per_voxel(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.slice_per_voxel`)
    }

    /**
     * How particles that left the domain are treated
     * @desc enum in ['DELETE', 'PUSHOUT'], default 'DELETE'
     */
    public get sndparticle_boundary(): 'DELETE' | 'PUSHOUT' {
        return PythonInterop.getEnum(this.interop, `${this.accessor}.sndparticle_boundary`)
    }

    /**
     * Determines which particle systems are created from secondary particles
     * @desc enum in ['OFF', 'SPRAY_FOAM', 'SPRAY_BUBBLES', 'FOAM_BUBBLES', 'SPRAY_FOAM_BUBBLES'], default 'OFF'
     */
    public get sndparticle_combined_export(): 'OFF' | 'SPRAY_FOAM' | 'SPRAY_BUBBLES' | 'FOAM_BUBBLES' | 'SPRAY_FOAM_BUBBLES' {
        return PythonInterop.getEnum(this.interop, `${this.accessor}.sndparticle_combined_export`)
    }

    /**
     * Amount of buoyancy force that rises bubbles (high value results in bubble movement mainly upwards)
     * @desc float in [0, 100], default 0.0
     */
    public get sndparticle_k_b(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.sndparticle_k_b`)
    }

    /**
     * Amount of drag force that moves bubbles along with the fluid (high value results in bubble movement mainly along with the fluid)
     * @desc float in [0, 100], default 0.0
     */
    public get sndparticle_k_d(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.sndparticle_k_d`)
    }

    /**
     * Maximum number of particles generated per trapped air cell per frame
     * @desc int in [0, 10000], default 0
     */
    public get sndparticle_k_ta(): number {
        return PythonInterop.getInteger(this.interop, `${this.accessor}.sndparticle_k_ta`)
    }

    /**
     * Maximum number of particles generated per wave crest cell per frame
     * @desc int in [0, 10000], default 0
     */
    public get sndparticle_k_wc(): number {
        return PythonInterop.getInteger(this.interop, `${this.accessor}.sndparticle_k_wc`)
    }

    /**
     * Highest possible particle lifetime
     * @desc float in [0, 10000], default 0.0
     */
    public get sndparticle_l_max(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.sndparticle_l_max`)
    }

    /**
     * Lowest possible particle lifetime
     * @desc float in [0, 10000], default 0.0
     */
    public get sndparticle_l_min(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.sndparticle_l_min`)
    }

    /**
     * Radius to compute potential for each cell (higher values are slower but create smoother potential grids)
     * @desc int in [1, 4], default 0
     */
    public get sndparticle_potential_radius(): number {
        return PythonInterop.getInteger(this.interop, `${this.accessor}.sndparticle_potential_radius`)
    }

    /**
     * Upper clamping threshold that indicates the fluid speed where cells no longer emit more particles (higher value results in generally less particles)
     * @desc float in [0, 1000], default 0.0
     */
    public get sndparticle_tau_max_k(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.sndparticle_tau_max_k`)
    }

    /**
     * Upper clamping threshold for marking fluid cells where air is trapped (highe value results in less marked cells)
     * @desc float in [0, 1000], default 0.0
     */
    public get sndparticle_tau_max_ta(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.sndparticle_tau_max_ta`)
    }

    /**
     * Upper clamping threshold for marking fluid cells as wave crests (higher value results in less marked cells)
     * @desc float in [0, 1000], default 0.0
     */
    public get sndparticle_tau_max_wc(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.sndparticle_tau_max_wc`)
    }

    /**
     * Lower clamping threshold that indicates the fluid speed where cells start to emit particles (lower values result in generally more particles)
     * @desc float in [0, 1000], default 0.0
     */
    public get sndparticle_tau_min_k(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.sndparticle_tau_min_k`)
    }

    /**
     * Lower clamping threshold for marking fluid cells where air is trapped (lower value results in more marked cells)
     * @desc float in [0, 1000], default 0.0
     */
    public get sndparticle_tau_min_ta(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.sndparticle_tau_min_ta`)
    }

    /**
     * Lower clamping threshold for marking fluid cells as wave crests (lower value results in more marked cells)
     * @desc float in [0, 1000], default 0.0
     */
    public get sndparticle_tau_min_wc(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.sndparticle_tau_min_wc`)
    }

    /**
     * Radius to compute position update for each particle (higher values are slower but particles move less chaotic)
     * @desc int in [1, 4], default 0
     */
    public get sndparticle_update_radius(): number {
        return PythonInterop.getInteger(this.interop, `${this.accessor}.sndparticle_update_radius`)
    }

    /**
     * Surface tension of liquid (higher value results in greater hydrophobic behaviour)
     * @desc float in [0, 100], default 0.0
     */
    public get surface_tension(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.surface_tension`)
    }

    /**
     * Adjust simulation speed
     * @desc float in [0.0001, 10], default 0.0
     */
    public get time_scale(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.time_scale`)
    }

    /**
     * Maximum number of simulation steps to perform for one frame
     * @desc int in [1, 100], default 0
     */
    public get timesteps_max(): number {
        return PythonInterop.getInteger(this.interop, `${this.accessor}.timesteps_max`)
    }

    /**
     * Minimum number of simulation steps to perform for one frame
     * @desc int in [1, 100], default 0
     */
    public get timesteps_min(): number {
        return PythonInterop.getInteger(this.interop, `${this.accessor}.timesteps_min`)
    }

    /**
     * Adapt simulation resolution and size to fluid
     * @desc boolean, default False
     */
    public get use_adaptive_domain(): boolean {
        return PythonInterop.getBoolean(this.interop, `${this.accessor}.use_adaptive_domain`)
    }

    /**
     * 
     * @desc boolean, default False
     */
    public get use_adaptive_timesteps(): boolean {
        return PythonInterop.getBoolean(this.interop, `${this.accessor}.use_adaptive_timesteps`)
    }

    /**
     * Create bubble particle system
     * @desc boolean, default False
     */
    public get use_bubble_particles(): boolean {
        return PythonInterop.getBoolean(this.interop, `${this.accessor}.use_bubble_particles`)
    }

    /**
     * Enable collisons with back domain border
     * @desc boolean, default False
     */
    public get use_collision_border_back(): boolean {
        return PythonInterop.getBoolean(this.interop, `${this.accessor}.use_collision_border_back`)
    }

    /**
     * Enable collisons with bottom domain border
     * @desc boolean, default False
     */
    public get use_collision_border_bottom(): boolean {
        return PythonInterop.getBoolean(this.interop, `${this.accessor}.use_collision_border_bottom`)
    }

    /**
     * Enable collisons with front domain border
     * @desc boolean, default False
     */
    public get use_collision_border_front(): boolean {
        return PythonInterop.getBoolean(this.interop, `${this.accessor}.use_collision_border_front`)
    }

    /**
     * Enable collisons with left domain border
     * @desc boolean, default False
     */
    public get use_collision_border_left(): boolean {
        return PythonInterop.getBoolean(this.interop, `${this.accessor}.use_collision_border_left`)
    }

    /**
     * Enable collisons with right domain border
     * @desc boolean, default False
     */
    public get use_collision_border_right(): boolean {
        return PythonInterop.getBoolean(this.interop, `${this.accessor}.use_collision_border_right`)
    }

    /**
     * Enable collisons with top domain border
     * @desc boolean, default False
     */
    public get use_collision_border_top(): boolean {
        return PythonInterop.getBoolean(this.interop, `${this.accessor}.use_collision_border_top`)
    }

    /**
     * Render a simulation field while mapping its voxels values to the colors of a ramp
     * @desc boolean, default False
     */
    public get use_color_ramp(): boolean {
        return PythonInterop.getBoolean(this.interop, `${this.accessor}.use_color_ramp`)
    }

    /**
     * Let smoke disappear over time
     * @desc boolean, default False
     */
    public get use_dissolve_smoke(): boolean {
        return PythonInterop.getBoolean(this.interop, `${this.accessor}.use_dissolve_smoke`)
    }

    /**
     * Dissolve smoke in a logarithmic fashion. Dissolves quickly at first, but lingers longer
     * @desc boolean, default False
     */
    public get use_dissolve_smoke_log(): boolean {
        return PythonInterop.getBoolean(this.interop, `${this.accessor}.use_dissolve_smoke_log`)
    }

    /**
     * Create liquid particle system
     * @desc boolean, default False
     */
    public get use_flip_particles(): boolean {
        return PythonInterop.getBoolean(this.interop, `${this.accessor}.use_flip_particles`)
    }

    /**
     * Create foam particle system
     * @desc boolean, default False
     */
    public get use_foam_particles(): boolean {
        return PythonInterop.getBoolean(this.interop, `${this.accessor}.use_foam_particles`)
    }

    /**
     * Fractional obstacles improve and smoothen the fluid-obstacle boundary
     * @desc boolean, default False
     */
    public get use_fractions(): boolean {
        return PythonInterop.getBoolean(this.interop, `${this.accessor}.use_fractions`)
    }

    /**
     * Enable fluid guiding
     * @desc boolean, default False
     */
    public get use_guide(): boolean {
        return PythonInterop.getBoolean(this.interop, `${this.accessor}.use_guide`)
    }

    /**
     * Enable fluid mesh (using amplification)
     * @desc boolean, default False
     */
    public get use_mesh(): boolean {
        return PythonInterop.getBoolean(this.interop, `${this.accessor}.use_mesh`)
    }

    /**
     * Enable fluid noise (using amplification)
     * @desc boolean, default False
     */
    public get use_noise(): boolean {
        return PythonInterop.getBoolean(this.interop, `${this.accessor}.use_noise`)
    }

    /**
     * Caches velocities of mesh vertices. These will be used (automatically) when rendering with motion blur enabled
     * @desc boolean, default False
     */
    public get use_speed_vectors(): boolean {
        return PythonInterop.getBoolean(this.interop, `${this.accessor}.use_speed_vectors`)
    }

    /**
     * Create spray particle system
     * @desc boolean, default False
     */
    public get use_spray_particles(): boolean {
        return PythonInterop.getBoolean(this.interop, `${this.accessor}.use_spray_particles`)
    }

    /**
     * Create tracer particle system
     * @desc boolean, default False
     */
    public get use_tracer_particles(): boolean {
        return PythonInterop.getBoolean(this.interop, `${this.accessor}.use_tracer_particles`)
    }

    /**
     * 
     * @desc enum in ['NEEDLE', 'STREAMLINE'], default 'NEEDLE'
     */
    public get vector_display_type(): 'NEEDLE' | 'STREAMLINE' {
        return PythonInterop.getEnum(this.interop, `${this.accessor}.vector_display_type`)
    }

    /**
     * Multiplier for scaling the vectors
     * @desc float in [0, 1000], default 0.0
     */
    public get vector_scale(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.vector_scale`)
    }

    /**
     * Viscosity setting: value that is multiplied by 10 to the power of (exponent*-1)
     * @desc float in [0, 10], default 0.0
     */
    public get viscosity_base(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.viscosity_base`)
    }

    /**
     * Negative exponent for the viscosity value (to simplify entering small values e.g. 5*10^-6)
     * @desc int in [0, 10], default 0
     */
    public get viscosity_exponent(): number {
        return PythonInterop.getInteger(this.interop, `${this.accessor}.viscosity_exponent`)
    }

    /**
     * Amount of turbulence and rotation in smoke
     * @desc float in [0, 4], default 0.0
     */
    public get vorticity(): number {
        return PythonInterop.getFloat(this.interop, `${this.accessor}.vorticity`)
    }

    /**
     * Margin added around fluid to minimize boundary interference
     * @desc int in [2, 24], default 0
     */
    public set adapt_margin(value: number) {
        PythonInterop.setInteger(this.interop, `${this.accessor}.adapt_margin`, value)
    }

    /**
     * Maximum amount of fluid cell can contain before it is considered empty
     * @desc float in [0, 1], default 0.0
     */
    public set adapt_threshold(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.adapt_threshold`, value)
    }

    /**
     * Maximum number of additional cells
     * @desc int in [0, 512], default 0
     */
    public set additional_res(value: number) {
        PythonInterop.setInteger(this.interop, `${this.accessor}.additional_res`, value)
    }

    /**
     * Buoyant force based on smoke density (higher value results in faster rising smoke)
     * @desc float in [-5, 5], default 0.0
     */
    public set alpha(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.alpha`, value)
    }

    /**
     * 
     * @desc enum in ['FULL', 'SINGLE'], default 'FULL'
     */
    public set axis_slice_method(value: 'FULL' | 'SINGLE') {
        PythonInterop.setEnum(this.interop, `${this.accessor}.axis_slice_method`, value)
    }

    /**
     * Buoyant force based on smoke heat (higher value results in faster rising smoke)
     * @desc float in [-5, 5], default 0.0
     */
    public set beta(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.beta`, value)
    }

    /**
     * Speed of the burning reaction (higher value results in smaller flames)
     * @desc float in [0.01, 4], default 0.0
     */
    public set burning_rate(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.burning_rate`, value)
    }

    /**
     * Select the file format to be used for caching volumetric data
     * @desc enum in ['NONE'], default 'NONE'
     */
    public set cache_data_format(value: 'NONE') {
        PythonInterop.setEnum(this.interop, `${this.accessor}.cache_data_format`, value)
    }

    /**
     * Directory that contains fluid cache files
     * @desc string, default '', (never None)
     */
    public set cache_directory(value: string) {
        PythonInterop.setString(this.interop, `${this.accessor}.cache_directory`, value)
    }

    /**
     * Frame on which the simulation stops
     * @desc int in [1, 1048574], default 0
     */
    public set cache_frame_end(value: number) {
        PythonInterop.setInteger(this.interop, `${this.accessor}.cache_frame_end`, value)
    }

    /**
     * 
     * @desc int in [-inf, inf], default 0
     */
    public set cache_frame_pause_data(value: number) {
        PythonInterop.setInteger(this.interop, `${this.accessor}.cache_frame_pause_data`, value)
    }

    /**
     * 
     * @desc int in [-inf, inf], default 0
     */
    public set cache_frame_pause_guide(value: number) {
        PythonInterop.setInteger(this.interop, `${this.accessor}.cache_frame_pause_guide`, value)
    }

    /**
     * 
     * @desc int in [-inf, inf], default 0
     */
    public set cache_frame_pause_mesh(value: number) {
        PythonInterop.setInteger(this.interop, `${this.accessor}.cache_frame_pause_mesh`, value)
    }

    /**
     * 
     * @desc int in [-inf, inf], default 0
     */
    public set cache_frame_pause_noise(value: number) {
        PythonInterop.setInteger(this.interop, `${this.accessor}.cache_frame_pause_noise`, value)
    }

    /**
     * 
     * @desc int in [-inf, inf], default 0
     */
    public set cache_frame_pause_particles(value: number) {
        PythonInterop.setInteger(this.interop, `${this.accessor}.cache_frame_pause_particles`, value)
    }

    /**
     * Frame on which the simulation starts
     * @desc int in [-1048574, 1048574], default 0
     */
    public set cache_frame_start(value: number) {
        PythonInterop.setInteger(this.interop, `${this.accessor}.cache_frame_start`, value)
    }

    /**
     * Select the file format to be used for caching surface data
     * @desc enum in ['NONE'], default 'NONE'
     */
    public set cache_mesh_format(value: 'NONE') {
        PythonInterop.setEnum(this.interop, `${this.accessor}.cache_mesh_format`, value)
    }

    /**
     * Select the file format to be used for caching noise data
     * @desc enum in ['NONE'], default 'NONE'
     */
    public set cache_noise_format(value: 'NONE') {
        PythonInterop.setEnum(this.interop, `${this.accessor}.cache_noise_format`, value)
    }

    /**
     * Select the file format to be used for caching particle data
     * @desc enum in ['NONE'], default 'NONE'
     */
    public set cache_particle_format(value: 'NONE') {
        PythonInterop.setEnum(this.interop, `${this.accessor}.cache_particle_format`, value)
    }

    /**
     * Change the cache type of the simulation
     * @desc enum in ['REPLAY', 'MODULAR', 'FINAL'], default 'REPLAY'
     */
    public set cache_type(value: 'REPLAY' | 'MODULAR' | 'FINAL') {
        PythonInterop.setEnum(this.interop, `${this.accessor}.cache_type`, value)
    }

    /**
     * Maximal velocity per cell (higher value results in greater timesteps)
     * @desc float in [0, 10], default 0.0
     */
    public set cfl_condition(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.cfl_condition`, value)
    }

    /**
     * Value under which voxels are considered empty space to optimize caching and rendering
     * @desc float in [0, 1], default 0.0
     */
    public set clipping(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.clipping`, value)
    }

    /**
     * Simulation field to color map
     * @desc enum in ['COLOR_R', 'COLOR_G', 'COLOR_B', 'DENSITY', 'FLAME', 'FUEL', 'HEAT', 'VELOCITY_X', 'VELOCITY_Y', 'VELOCITY_Z'], default 'DENSITY'
     */
    public set coba_field(value: 'COLOR_R' | 'COLOR_G' | 'COLOR_B' | 'DENSITY' | 'FLAME' | 'FUEL' | 'HEAT' | 'VELOCITY_X' | 'VELOCITY_Y' | 'VELOCITY_Z') {
        PythonInterop.setEnum(this.interop, `${this.accessor}.coba_field`, value)
    }

    /**
     * Bit depth for writing all scalar (including vector) lower values reduce file size
     * @desc enum in ['16', '32'], default '32'
     */
    public set data_depth(value: '16' | '32') {
        PythonInterop.setEnum(this.interop, `${this.accessor}.data_depth`, value)
    }

    /**
     * Interpolation method to use for smoke/fire volumes in solid mode
     * @desc enum in ['LINEAR', 'CUBIC'], default 'LINEAR'
     */
    public set display_interpolation(value: 'LINEAR' | 'CUBIC') {
        PythonInterop.setEnum(this.interop, `${this.accessor}.display_interpolation`, value)
    }

    /**
     * Thickness of smoke drawing in the viewport
     * @desc float in [0.001, 1000], default 0.0
     */
    public set display_thickness(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.display_thickness`, value)
    }

    /**
     * Determine how quickly the smoke dissolves (higher value makes smoke disappear faster)
     * @desc int in [1, 10000], default 0
     */
    public set dissolve_speed(value: number) {
        PythonInterop.setInteger(this.interop, `${this.accessor}.dissolve_speed`, value)
    }

    /**
     * Domain size in meters (longest domain side)
     * @desc float in [0.001, 10000], default 0.0
     */
    public set domain_size(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.domain_size`, value)
    }

    /**
     * Change domain type of the simulation
     * @desc enum in ['GAS', 'LIQUID'], default 'GAS'
     */
    public set domain_type(value: 'GAS' | 'LIQUID') {
        PythonInterop.setEnum(this.interop, `${this.accessor}.domain_type`, value)
    }

    /**
     * Limit effectors to this collection
     * @desc Collection
     */
    public set effector_group(value: Collection) {
        PythonInterop.setClass(this.interop, `${this.accessor}.effector_group`, value)
    }

    /**
     * Generate and export Fluidflow script from current domain settings during bake. This is only needed if you plan to analyse the cache (e.g. view grids, velocity vectors, particles) in Fluidflow directly (outside of Blender) after baking the simulation
     * @desc boolean, default False
     */
    public set export_manta_script(value: boolean) {
        PythonInterop.setBoolean(this.interop, `${this.accessor}.export_manta_script`, value)
    }

    /**
     * Minimum temperature of the flames (higher value results in faster rising flames)
     * @desc float in [0.5, 5], default 0.0
     */
    public set flame_ignition(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.flame_ignition`, value)
    }

    /**
     * Maximum temperature of the flames (higher value results in faster rising flames)
     * @desc float in [1, 10], default 0.0
     */
    public set flame_max_temp(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.flame_max_temp`, value)
    }

    /**
     * Amount of smoke created by burning fuel
     * @desc float in [0, 8], default 0.0
     */
    public set flame_smoke(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.flame_smoke`, value)
    }

    /**
     * Color of smoke emitted from burning fuel
     * @desc float array of 3 items in [0, inf], default (0.0, 0.0, 0.0)
     */
    public set flame_smoke_color(value: [number, number, number]) {
        PythonInterop.setArray(this.interop, `${this.accessor}.flame_smoke_color`, value)
    }

    /**
     * Additional vorticity for the flames
     * @desc float in [0, 2], default 0.0
     */
    public set flame_vorticity(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.flame_vorticity`, value)
    }

    /**
     * PIC/FLIP Ratio. A value of 1.0 will result in a completely FLIP based simulation. Use a lower value for simulations which should produce smaller splashes
     * @desc float in [0, 1], default 0.0
     */
    public set flip_ratio(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.flip_ratio`, value)
    }

    /**
     * Limit fluid objects to this collection
     * @desc Collection
     */
    public set fluid_group(value: Collection) {
        PythonInterop.setClass(this.interop, `${this.accessor}.fluid_group`, value)
    }

    /**
     * Limit forces to this collection
     * @desc Collection
     */
    public set force_collection(value: Collection) {
        PythonInterop.setClass(this.interop, `${this.accessor}.force_collection`, value)
    }

    /**
     * Determines how much fluid is allowed in an obstacle cell (higher values will tag a boundary cell as an obstacle easier and reduce the boundary smoothening effect)
     * @desc float in [0.001, 1], default 0.0
     */
    public set fractions_threshold(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.fractions_threshold`, value)
    }

    /**
     * Gravity in X, Y and Z direction
     * @desc float array of 3 items in [-1000.1, 1000.1], default (0.0, 0.0, 0.0)
     */
    public set gravity(value: [number, number, number]) {
        PythonInterop.setArray(this.interop, `${this.accessor}.gravity`, value)
    }

    /**
     * Guiding weight (higher value results in greater lag)
     * @desc float in [1, 100], default 0.0
     */
    public set guide_alpha(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.guide_alpha`, value)
    }

    /**
     * Guiding size (higher value results in larger vortices)
     * @desc int in [1, 50], default 0
     */
    public set guide_beta(value: number) {
        PythonInterop.setInteger(this.interop, `${this.accessor}.guide_beta`, value)
    }

    /**
     * Use velocities from this object for the guiding effect (object needs to have fluid modifier and be of type domain))
     * @desc Object
     */
    public set guide_parent(value: BlenderObject) {
        PythonInterop.setClass(this.interop, `${this.accessor}.guide_parent`, value)
    }

    /**
     * Choose where to get guiding velocities from
     * @desc enum in ['DOMAIN', 'EFFECTOR'], default 'DOMAIN'
     */
    public set guide_source(value: 'DOMAIN' | 'EFFECTOR') {
        PythonInterop.setEnum(this.interop, `${this.accessor}.guide_source`, value)
    }

    /**
     * Guiding velocity factor (higher value results in greater guiding velocities)
     * @desc float in [0, 100], default 0.0
     */
    public set guide_vel_factor(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.guide_vel_factor`, value)
    }

    /**
     * 
     * @desc boolean, default False
     */
    public set has_cache_baked_any(value: boolean) {
        PythonInterop.setBoolean(this.interop, `${this.accessor}.has_cache_baked_any`, value)
    }

    /**
     * 
     * @desc boolean, default False
     */
    public set has_cache_baked_data(value: boolean) {
        PythonInterop.setBoolean(this.interop, `${this.accessor}.has_cache_baked_data`, value)
    }

    /**
     * 
     * @desc boolean, default False
     */
    public set has_cache_baked_guide(value: boolean) {
        PythonInterop.setBoolean(this.interop, `${this.accessor}.has_cache_baked_guide`, value)
    }

    /**
     * 
     * @desc boolean, default False
     */
    public set has_cache_baked_mesh(value: boolean) {
        PythonInterop.setBoolean(this.interop, `${this.accessor}.has_cache_baked_mesh`, value)
    }

    /**
     * 
     * @desc boolean, default False
     */
    public set has_cache_baked_noise(value: boolean) {
        PythonInterop.setBoolean(this.interop, `${this.accessor}.has_cache_baked_noise`, value)
    }

    /**
     * 
     * @desc boolean, default False
     */
    public set has_cache_baked_particles(value: boolean) {
        PythonInterop.setBoolean(this.interop, `${this.accessor}.has_cache_baked_particles`, value)
    }

    /**
     * Method for sampling the high resolution flow
     * @desc enum in ['FULLSAMPLE', 'LINEAR', 'NEAREST'], default 'NEAREST'
     */
    public set highres_sampling(value: 'FULLSAMPLE' | 'LINEAR' | 'NEAREST') {
        PythonInterop.setEnum(this.interop, `${this.accessor}.highres_sampling`, value)
    }

    /**
     * 
     * @desc boolean, default False
     */
    public set is_cache_baking_any(value: boolean) {
        PythonInterop.setBoolean(this.interop, `${this.accessor}.is_cache_baking_any`, value)
    }

    /**
     * 
     * @desc boolean, default False
     */
    public set is_cache_baking_data(value: boolean) {
        PythonInterop.setBoolean(this.interop, `${this.accessor}.is_cache_baking_data`, value)
    }

    /**
     * 
     * @desc boolean, default False
     */
    public set is_cache_baking_guide(value: boolean) {
        PythonInterop.setBoolean(this.interop, `${this.accessor}.is_cache_baking_guide`, value)
    }

    /**
     * 
     * @desc boolean, default False
     */
    public set is_cache_baking_mesh(value: boolean) {
        PythonInterop.setBoolean(this.interop, `${this.accessor}.is_cache_baking_mesh`, value)
    }

    /**
     * 
     * @desc boolean, default False
     */
    public set is_cache_baking_noise(value: boolean) {
        PythonInterop.setBoolean(this.interop, `${this.accessor}.is_cache_baking_noise`, value)
    }

    /**
     * 
     * @desc boolean, default False
     */
    public set is_cache_baking_particles(value: boolean) {
        PythonInterop.setBoolean(this.interop, `${this.accessor}.is_cache_baking_particles`, value)
    }

    /**
     * Lower mesh concavity bound (high values tend to smoothen and fill out concave regions)
     * @desc float in [0, 10], default 0.0
     */
    public set mesh_concave_lower(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.mesh_concave_lower`, value)
    }

    /**
     * Upper mesh concavity bound (high values tend to smoothen and fill out concave regions)
     * @desc float in [0, 10], default 0.0
     */
    public set mesh_concave_upper(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.mesh_concave_upper`, value)
    }

    /**
     * Which particle levelset generator to use
     * @desc enum in ['IMPROVED', 'UNION'], default 'IMPROVED'
     */
    public set mesh_generator(value: 'IMPROVED' | 'UNION') {
        PythonInterop.setEnum(this.interop, `${this.accessor}.mesh_generator`, value)
    }

    /**
     * Particle radius factor (higher value results in larger (meshed) particles). Needs to be adjusted after changing the mesh scale
     * @desc float in [0, 10], default 0.0
     */
    public set mesh_particle_radius(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.mesh_particle_radius`, value)
    }

    /**
     * The mesh simulation is scaled up by this factor (compared to the base resolution of the domain). For best meshing, it is recommended to adjust the mesh particle radius alongside this value
     * @desc int in [1, 100], default 0
     */
    public set mesh_scale(value: number) {
        PythonInterop.setInteger(this.interop, `${this.accessor}.mesh_scale`, value)
    }

    /**
     * Negative mesh smoothening
     * @desc int in [0, 100], default 0
     */
    public set mesh_smoothen_neg(value: number) {
        PythonInterop.setInteger(this.interop, `${this.accessor}.mesh_smoothen_neg`, value)
    }

    /**
     * Positive mesh smoothening
     * @desc int in [0, 100], default 0
     */
    public set mesh_smoothen_pos(value: number) {
        PythonInterop.setInteger(this.interop, `${this.accessor}.mesh_smoothen_pos`, value)
    }

    /**
     * Scale of noise (higher value results in larger vortices)
     * @desc float in [0.0001, 10], default 0.0
     */
    public set noise_pos_scale(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.noise_pos_scale`, value)
    }

    /**
     * The noise simulation is scaled up by this factor (compared to the base resolution of the domain)
     * @desc int in [1, 100], default 0
     */
    public set noise_scale(value: number) {
        PythonInterop.setInteger(this.interop, `${this.accessor}.noise_scale`, value)
    }

    /**
     * Strength of noise
     * @desc float in [0, 10], default 0.0
     */
    public set noise_strength(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.noise_strength`, value)
    }

    /**
     * Animation time of noise
     * @desc float in [0.0001, 10], default 0.0
     */
    public set noise_time_anim(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.noise_time_anim`, value)
    }

    /**
     * Noise method which is used during the high-res simulation
     * @desc enum in ['NOISEWAVE'], default 'NOISEWAVE'
     */
    public set noise_type(value: 'NOISEWAVE') {
        PythonInterop.setEnum(this.interop, `${this.accessor}.noise_type`, value)
    }

    /**
     * Compression method to be used
     * @desc enum in ['ZIP', 'BLOSC', 'NONE'], default 'BLOSC'
     */
    public set openvdb_cache_compress_type(value: 'ZIP' | 'BLOSC' | 'NONE') {
        PythonInterop.setEnum(this.interop, `${this.accessor}.openvdb_cache_compress_type`, value)
    }

    /**
     * Particle (narrow) band width (higher value results in thicker band and more particles)
     * @desc float in [0, 1000], default 0.0
     */
    public set particle_band_width(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.particle_band_width`, value)
    }

    /**
     * Maximum number of particles per cell (ensures that each cell has at most this amount of particles)
     * @desc int in [0, 1000], default 0
     */
    public set particle_max(value: number) {
        PythonInterop.setInteger(this.interop, `${this.accessor}.particle_max`, value)
    }

    /**
     * Minimum number of particles per cell (ensures that each cell has at least this amount of particles)
     * @desc int in [0, 1000], default 0
     */
    public set particle_min(value: number) {
        PythonInterop.setInteger(this.interop, `${this.accessor}.particle_min`, value)
    }

    /**
     * Particle number factor (higher value results in more particles)
     * @desc int in [1, 5], default 0
     */
    public set particle_number(value: number) {
        PythonInterop.setInteger(this.interop, `${this.accessor}.particle_number`, value)
    }

    /**
     * Particle radius factor. Increase this value if the simulation appears to leak volume, decrease it if the simulation seems to gain volume
     * @desc float in [0, 10], default 0.0
     */
    public set particle_radius(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.particle_radius`, value)
    }

    /**
     * Randomness factor for particle sampling
     * @desc float in [0, 10], default 0.0
     */
    public set particle_randomness(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.particle_randomness`, value)
    }

    /**
     * The particle simulation is scaled up by this factor (compared to the base resolution of the domain)
     * @desc int in [1, 100], default 0
     */
    public set particle_scale(value: number) {
        PythonInterop.setInteger(this.interop, `${this.accessor}.particle_scale`, value)
    }

    /**
     * Compression method to be used
     * @desc enum in ['CACHELIGHT', 'CACHEHEAVY'], default 'CACHELIGHT'
     */
    public set point_cache_compress_type(value: 'CACHELIGHT' | 'CACHEHEAVY') {
        PythonInterop.setEnum(this.interop, `${this.accessor}.point_cache_compress_type`, value)
    }

    /**
     * Resolution used for the fluid domain. Value corresponds to the longest domain side (resolution for other domain sides is calculated automatically)
     * @desc int in [6, 10000], default 0
     */
    public set resolution_max(value: number) {
        PythonInterop.setInteger(this.interop, `${this.accessor}.resolution_max`, value)
    }

    /**
     * Toggle visualization of the velocity field as needles
     * @desc boolean, default False
     */
    public set show_velocity(value: boolean) {
        PythonInterop.setBoolean(this.interop, `${this.accessor}.show_velocity`, value)
    }

    /**
     * Change the underlying simulation method
     * @desc enum in ['FLIP'], default 'FLIP'
     */
    public set simulation_method(value: 'FLIP') {
        PythonInterop.setEnum(this.interop, `${this.accessor}.simulation_method`, value)
    }

    /**
     * 
     * @desc enum in ['AUTO', 'X', 'Y', 'Z'], default 'AUTO'
     */
    public set slice_axis(value: 'AUTO' | 'X' | 'Y' | 'Z') {
        PythonInterop.setEnum(this.interop, `${this.accessor}.slice_axis`, value)
    }

    /**
     * Position of the slice
     * @desc float in [0, 1], default 0.0
     */
    public set slice_depth(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.slice_depth`, value)
    }

    /**
     * How to slice the volume for viewport rendering
     * @desc enum in ['VIEW_ALIGNED', 'AXIS_ALIGNED'], default 'VIEW_ALIGNED'
     */
    public set slice_method(value: 'VIEW_ALIGNED' | 'AXIS_ALIGNED') {
        PythonInterop.setEnum(this.interop, `${this.accessor}.slice_method`, value)
    }

    /**
     * How many slices per voxel should be generated
     * @desc float in [0, 100], default 0.0
     */
    public set slice_per_voxel(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.slice_per_voxel`, value)
    }

    /**
     * How particles that left the domain are treated
     * @desc enum in ['DELETE', 'PUSHOUT'], default 'DELETE'
     */
    public set sndparticle_boundary(value: 'DELETE' | 'PUSHOUT') {
        PythonInterop.setEnum(this.interop, `${this.accessor}.sndparticle_boundary`, value)
    }

    /**
     * Determines which particle systems are created from secondary particles
     * @desc enum in ['OFF', 'SPRAY_FOAM', 'SPRAY_BUBBLES', 'FOAM_BUBBLES', 'SPRAY_FOAM_BUBBLES'], default 'OFF'
     */
    public set sndparticle_combined_export(value: 'OFF' | 'SPRAY_FOAM' | 'SPRAY_BUBBLES' | 'FOAM_BUBBLES' | 'SPRAY_FOAM_BUBBLES') {
        PythonInterop.setEnum(this.interop, `${this.accessor}.sndparticle_combined_export`, value)
    }

    /**
     * Amount of buoyancy force that rises bubbles (high value results in bubble movement mainly upwards)
     * @desc float in [0, 100], default 0.0
     */
    public set sndparticle_k_b(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.sndparticle_k_b`, value)
    }

    /**
     * Amount of drag force that moves bubbles along with the fluid (high value results in bubble movement mainly along with the fluid)
     * @desc float in [0, 100], default 0.0
     */
    public set sndparticle_k_d(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.sndparticle_k_d`, value)
    }

    /**
     * Maximum number of particles generated per trapped air cell per frame
     * @desc int in [0, 10000], default 0
     */
    public set sndparticle_k_ta(value: number) {
        PythonInterop.setInteger(this.interop, `${this.accessor}.sndparticle_k_ta`, value)
    }

    /**
     * Maximum number of particles generated per wave crest cell per frame
     * @desc int in [0, 10000], default 0
     */
    public set sndparticle_k_wc(value: number) {
        PythonInterop.setInteger(this.interop, `${this.accessor}.sndparticle_k_wc`, value)
    }

    /**
     * Highest possible particle lifetime
     * @desc float in [0, 10000], default 0.0
     */
    public set sndparticle_l_max(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.sndparticle_l_max`, value)
    }

    /**
     * Lowest possible particle lifetime
     * @desc float in [0, 10000], default 0.0
     */
    public set sndparticle_l_min(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.sndparticle_l_min`, value)
    }

    /**
     * Radius to compute potential for each cell (higher values are slower but create smoother potential grids)
     * @desc int in [1, 4], default 0
     */
    public set sndparticle_potential_radius(value: number) {
        PythonInterop.setInteger(this.interop, `${this.accessor}.sndparticle_potential_radius`, value)
    }

    /**
     * Upper clamping threshold that indicates the fluid speed where cells no longer emit more particles (higher value results in generally less particles)
     * @desc float in [0, 1000], default 0.0
     */
    public set sndparticle_tau_max_k(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.sndparticle_tau_max_k`, value)
    }

    /**
     * Upper clamping threshold for marking fluid cells where air is trapped (highe value results in less marked cells)
     * @desc float in [0, 1000], default 0.0
     */
    public set sndparticle_tau_max_ta(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.sndparticle_tau_max_ta`, value)
    }

    /**
     * Upper clamping threshold for marking fluid cells as wave crests (higher value results in less marked cells)
     * @desc float in [0, 1000], default 0.0
     */
    public set sndparticle_tau_max_wc(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.sndparticle_tau_max_wc`, value)
    }

    /**
     * Lower clamping threshold that indicates the fluid speed where cells start to emit particles (lower values result in generally more particles)
     * @desc float in [0, 1000], default 0.0
     */
    public set sndparticle_tau_min_k(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.sndparticle_tau_min_k`, value)
    }

    /**
     * Lower clamping threshold for marking fluid cells where air is trapped (lower value results in more marked cells)
     * @desc float in [0, 1000], default 0.0
     */
    public set sndparticle_tau_min_ta(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.sndparticle_tau_min_ta`, value)
    }

    /**
     * Lower clamping threshold for marking fluid cells as wave crests (lower value results in more marked cells)
     * @desc float in [0, 1000], default 0.0
     */
    public set sndparticle_tau_min_wc(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.sndparticle_tau_min_wc`, value)
    }

    /**
     * Radius to compute position update for each particle (higher values are slower but particles move less chaotic)
     * @desc int in [1, 4], default 0
     */
    public set sndparticle_update_radius(value: number) {
        PythonInterop.setInteger(this.interop, `${this.accessor}.sndparticle_update_radius`, value)
    }

    /**
     * Surface tension of liquid (higher value results in greater hydrophobic behaviour)
     * @desc float in [0, 100], default 0.0
     */
    public set surface_tension(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.surface_tension`, value)
    }

    /**
     * Adjust simulation speed
     * @desc float in [0.0001, 10], default 0.0
     */
    public set time_scale(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.time_scale`, value)
    }

    /**
     * Maximum number of simulation steps to perform for one frame
     * @desc int in [1, 100], default 0
     */
    public set timesteps_max(value: number) {
        PythonInterop.setInteger(this.interop, `${this.accessor}.timesteps_max`, value)
    }

    /**
     * Minimum number of simulation steps to perform for one frame
     * @desc int in [1, 100], default 0
     */
    public set timesteps_min(value: number) {
        PythonInterop.setInteger(this.interop, `${this.accessor}.timesteps_min`, value)
    }

    /**
     * Adapt simulation resolution and size to fluid
     * @desc boolean, default False
     */
    public set use_adaptive_domain(value: boolean) {
        PythonInterop.setBoolean(this.interop, `${this.accessor}.use_adaptive_domain`, value)
    }

    /**
     * 
     * @desc boolean, default False
     */
    public set use_adaptive_timesteps(value: boolean) {
        PythonInterop.setBoolean(this.interop, `${this.accessor}.use_adaptive_timesteps`, value)
    }

    /**
     * Create bubble particle system
     * @desc boolean, default False
     */
    public set use_bubble_particles(value: boolean) {
        PythonInterop.setBoolean(this.interop, `${this.accessor}.use_bubble_particles`, value)
    }

    /**
     * Enable collisons with back domain border
     * @desc boolean, default False
     */
    public set use_collision_border_back(value: boolean) {
        PythonInterop.setBoolean(this.interop, `${this.accessor}.use_collision_border_back`, value)
    }

    /**
     * Enable collisons with bottom domain border
     * @desc boolean, default False
     */
    public set use_collision_border_bottom(value: boolean) {
        PythonInterop.setBoolean(this.interop, `${this.accessor}.use_collision_border_bottom`, value)
    }

    /**
     * Enable collisons with front domain border
     * @desc boolean, default False
     */
    public set use_collision_border_front(value: boolean) {
        PythonInterop.setBoolean(this.interop, `${this.accessor}.use_collision_border_front`, value)
    }

    /**
     * Enable collisons with left domain border
     * @desc boolean, default False
     */
    public set use_collision_border_left(value: boolean) {
        PythonInterop.setBoolean(this.interop, `${this.accessor}.use_collision_border_left`, value)
    }

    /**
     * Enable collisons with right domain border
     * @desc boolean, default False
     */
    public set use_collision_border_right(value: boolean) {
        PythonInterop.setBoolean(this.interop, `${this.accessor}.use_collision_border_right`, value)
    }

    /**
     * Enable collisons with top domain border
     * @desc boolean, default False
     */
    public set use_collision_border_top(value: boolean) {
        PythonInterop.setBoolean(this.interop, `${this.accessor}.use_collision_border_top`, value)
    }

    /**
     * Render a simulation field while mapping its voxels values to the colors of a ramp
     * @desc boolean, default False
     */
    public set use_color_ramp(value: boolean) {
        PythonInterop.setBoolean(this.interop, `${this.accessor}.use_color_ramp`, value)
    }

    /**
     * Let smoke disappear over time
     * @desc boolean, default False
     */
    public set use_dissolve_smoke(value: boolean) {
        PythonInterop.setBoolean(this.interop, `${this.accessor}.use_dissolve_smoke`, value)
    }

    /**
     * Dissolve smoke in a logarithmic fashion. Dissolves quickly at first, but lingers longer
     * @desc boolean, default False
     */
    public set use_dissolve_smoke_log(value: boolean) {
        PythonInterop.setBoolean(this.interop, `${this.accessor}.use_dissolve_smoke_log`, value)
    }

    /**
     * Create liquid particle system
     * @desc boolean, default False
     */
    public set use_flip_particles(value: boolean) {
        PythonInterop.setBoolean(this.interop, `${this.accessor}.use_flip_particles`, value)
    }

    /**
     * Create foam particle system
     * @desc boolean, default False
     */
    public set use_foam_particles(value: boolean) {
        PythonInterop.setBoolean(this.interop, `${this.accessor}.use_foam_particles`, value)
    }

    /**
     * Fractional obstacles improve and smoothen the fluid-obstacle boundary
     * @desc boolean, default False
     */
    public set use_fractions(value: boolean) {
        PythonInterop.setBoolean(this.interop, `${this.accessor}.use_fractions`, value)
    }

    /**
     * Enable fluid guiding
     * @desc boolean, default False
     */
    public set use_guide(value: boolean) {
        PythonInterop.setBoolean(this.interop, `${this.accessor}.use_guide`, value)
    }

    /**
     * Enable fluid mesh (using amplification)
     * @desc boolean, default False
     */
    public set use_mesh(value: boolean) {
        PythonInterop.setBoolean(this.interop, `${this.accessor}.use_mesh`, value)
    }

    /**
     * Enable fluid noise (using amplification)
     * @desc boolean, default False
     */
    public set use_noise(value: boolean) {
        PythonInterop.setBoolean(this.interop, `${this.accessor}.use_noise`, value)
    }

    /**
     * Caches velocities of mesh vertices. These will be used (automatically) when rendering with motion blur enabled
     * @desc boolean, default False
     */
    public set use_speed_vectors(value: boolean) {
        PythonInterop.setBoolean(this.interop, `${this.accessor}.use_speed_vectors`, value)
    }

    /**
     * Create spray particle system
     * @desc boolean, default False
     */
    public set use_spray_particles(value: boolean) {
        PythonInterop.setBoolean(this.interop, `${this.accessor}.use_spray_particles`, value)
    }

    /**
     * Create tracer particle system
     * @desc boolean, default False
     */
    public set use_tracer_particles(value: boolean) {
        PythonInterop.setBoolean(this.interop, `${this.accessor}.use_tracer_particles`, value)
    }

    /**
     * 
     * @desc enum in ['NEEDLE', 'STREAMLINE'], default 'NEEDLE'
     */
    public set vector_display_type(value: 'NEEDLE' | 'STREAMLINE') {
        PythonInterop.setEnum(this.interop, `${this.accessor}.vector_display_type`, value)
    }

    /**
     * Multiplier for scaling the vectors
     * @desc float in [0, 1000], default 0.0
     */
    public set vector_scale(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.vector_scale`, value)
    }

    /**
     * Viscosity setting: value that is multiplied by 10 to the power of (exponent*-1)
     * @desc float in [0, 10], default 0.0
     */
    public set viscosity_base(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.viscosity_base`, value)
    }

    /**
     * Negative exponent for the viscosity value (to simplify entering small values e.g. 5*10^-6)
     * @desc int in [0, 10], default 0
     */
    public set viscosity_exponent(value: number) {
        PythonInterop.setInteger(this.interop, `${this.accessor}.viscosity_exponent`, value)
    }

    /**
     * Amount of turbulence and rotation in smoke
     * @desc float in [0, 4], default 0.0
     */
    public set vorticity(value: number) {
        PythonInterop.setFloat(this.interop, `${this.accessor}.vorticity`, value)
    }

    [util.inspect.custom]() {
        return this.accessor
    }
}
